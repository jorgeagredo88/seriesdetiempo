[["remesas.html", "Series de tiempo - Remesas 1 REMESAS 1.1 INTRODUCCIÓN 1.2 BASE DE DATOS", " Series de tiempo - Remesas Analisis de Series de Tiempo Grupo 5 - William Contreras, Camilo Espinoza, Jorge Agredo 2024-11-04 1 REMESAS 1.1 INTRODUCCIÓN Las remesas son transferencias de dinero realizadas principalmente por emigrantes a sus familiares o relacionados en su país de origen. En este proceso participan los siguientes actores: remitente (persona que desde el país de origen se acerca a un agente para enviar un determinado monto), el agente en el lugar de origen (oficina donde se inicia la operación financiera), la empresa de transferencia de dinero (empresa que hace el traslado del monto del país de origen al país destino), el agente en el lugar de pago (oficina donde se realiza el desembolso del dinero) y el receptor (persona que en el país de destino recibe el dinero). Las transferencias entre la empresa de transferencia y los agentes se realizan en dólares, y las tasas de cambio se fijan en la fecha de origen de la transacción con una tasa de referencia establecida para cada país. Esto significa que todas las transacciones iniciadas en el día  se pagarán según la tasa de referencia correspondiente a ese día. Esto genera un desafío para los agentes en el lugar de pago, dado que la tasa de pago asociada a las operaciones es informada al remitente y se fija según la tasa de referencia vigente en la fecha de origen y se mantiene inalterada hasta que el giro es cobrado. Existe una exposición a la volatilidad de la tasa de cambio entre el día inicial de la transacción y la fecha de cobro. Estas transacciones se identifican el día en que se realiza el pago al receptor, momento en que la tasa de mercado a la que el agente de pago convierte a moneda local los dólares recibidos por la empresa de transferencia de dinero puede haber variado con relación a la tasa de cambio con la que se fijó la conversión al momento de la originación de la remesa. En resumen, hay transacciones pagadas en el día  que tienen como referencia una tasa de cambio de un día diferente, y el agente del lugar de pago puede monetizar (convertir de dólares a pesos colombianos) a la tasa del día . De esta forma, en escenarios de revaluación del peso colombiano, es decir, caídas en la tasa de cambio, se generarían menores ingresos o pérdidas por concepto de monetización de dólares, materializándose el riesgo cambiario. Este proceso se ve afectado por las celebraciones especiales en cada uno de los países, tales como día de amor y amistad, día de la madre, navidad, etc. 1.2 BASE DE DATOS Según lo expuesto anteriormente, se identifican las siguientes variables para el conjunto de datos provisto por una entidad que realiza remesas en Colombia bajo acuerdo de confidencialidad: Fecha de pago. Canal. Pais de Origen. Número de transacciones. Fecha de origen. Monto en dolares. Monto en Pesos. En relación con la importancia de analizar esta información enfocado en la variable tiempo se puede decir que; el análisis de las variables de tipo fecha (Fecha origen de la operación y Fecha de pago) es crucial debido a la volatilidad de las tasas de cambio entre el día en que se origina la remesa y el día en que se paga. Por otra parte, el pronóstico del monto total a pagar en remesas es esencial para mitigar este riesgo, permitiendo anticipar posibles pérdidas por variaciones en la tasa de cambio y tomar decisiones informadas sobre cobertura y gestión del riesgo. Inicialmente los datos comprenden el periodo entre el primero de enero de 2023 hasta el 10 de octubre de 2024 de forma díaria, pero se irá aumentando los datos en la medida que la empresa entregue la información. "],["descripción-de-las-series-de-tiempo.html", "2 DESCRIPCIÓN DE LAS SERIES DE TIEMPO 2.1 Serie de tiempo por Fecha de Pago 2.2 Serie de tiempo por Fecha de Origen", " 2 DESCRIPCIÓN DE LAS SERIES DE TIEMPO A continuación se presenta la base incluyendo la variable en el tiempo, la aproximación en promedios móviles, en rezagos y en estacionalidad. Todo lo anterior, a través de funciones y gráficas que permitan detectar patrones y ciclos de la variable. ## Rows: 529,464 ## Columns: 7 ## $ Fecha_Pago &lt;date&gt; 2023-01-01, 2023-01-01, 2023-01-01, 2023-01-01, 2023-01-01, 2023-01-01, 2023-01-01,~ ## $ Pais_Origen &lt;chr&gt; &quot;AE&quot;, &quot;AE&quot;, &quot;AT&quot;, &quot;AU&quot;, &quot;AU&quot;, &quot;BE&quot;, &quot;BE&quot;, &quot;BR&quot;, &quot;BR&quot;, &quot;BR&quot;, &quot;BR&quot;, &quot;CA&quot;, &quot;CA&quot;, &quot;CA&quot;, ~ ## $ Fecha_Origen &lt;date&gt; 2022-12-31, 2023-01-01, 2023-01-01, 2022-12-31, 2023-01-01, 2022-12-30, 2023-01-01,~ ## $ Canal &lt;chr&gt; &quot;APN&quot;, &quot;APN&quot;, &quot;APN&quot;, &quot;APN&quot;, &quot;APN&quot;, &quot;RedPropia&quot;, &quot;APN&quot;, &quot;APN&quot;, &quot;RedPropia&quot;, &quot;APN&quot;, &quot;R~ ## $ Transacciones_USD &lt;dbl&gt; 1, 3, 3, 3, 18, 1, 1, 12, 2, 35, 1, 2, 2, 17, 2, 1, 1, 1, 22, 1, 1, 2, 1, 2, 1, 2, 1~ ## $ Monto_USD &lt;dbl&gt; 369.33, 471.03, 1146.18, 1781.49, 13945.66, 48.23, 418.29, 2206.27, 414.72, 10959.17~ ## $ Monto_COP &lt;dbl&gt; 1765896, 2252157, 5480357, 8518037, 66679489, 230602, 2000000, 10549058, 1982944, 52~ Como se puede observar en la tabla resumen la base de datos se compone de 7 variables: 2 tipo fecha: Fecha_pago y Fecha_Origen, 3 numericas: Número_transacciones, Monto_USD y Monto_COP y 2 tipo texto: Pais_Origen y Canal. Con el objetivo de observar el comportamiento de las remesas en el tiempo, se realizará la descripción por las dos variables tipo fecha. 2.1 Serie de tiempo por Fecha de Pago Se agrupa el monto en dólares por la variable objetivo. Datos_FP &lt;- aggregate(Monto_USD ~ Fecha_Pago, data = Datos, sum) Se verifica el tipo de variable. ## [1] &quot;ts&quot; La fecha inicial ## [1] 2023 1 La fecha final ## [1] 2024 284 Se puede evidenciar que comienza el día 1 del 2023 y finaliza el día 284 del año 2024. Se valido que las fechas fueran consecutivas y no existieran fechas faltantes. fecha_min &lt;- min(Datos_FP$Fecha_Pago) fecha_max &lt;- max(Datos_FP$Fecha_Pago) fechas_completas &lt;- seq(from = fecha_min, to = fecha_max, by = &quot;day&quot;) fechas_faltantes &lt;- setdiff(fechas_completas, Datos_FP$Fecha_Pago) fechas_faltantes ## numeric(0) A continuación se realiza el gráfico del monto en dólares por fecha de pago. 2.1.1 Uso de la librería XTS A pesar de conocer que la base es regular con periodicidad diaria, se decidió usar la libreria XTS por la utilización de las fechas exactas. # Crear la serie de tiempo serie_xts &lt;- xts(Datos_FP$Monto_USD, order.by = Datos_FP$Fecha_Pago) head(serie_xts) ## [,1] ## 2023-01-01 314473.1 ## 2023-01-02 4700346.1 ## 2023-01-03 6069974.1 ## 2023-01-04 6164948.9 ## 2023-01-05 6986643.0 ## 2023-01-06 6616416.0 2.1.2 Gráfico de rezago para la serie de tiempo Según la gráfica parece que existe algo de autocorrelación hasta el rezago 4, para mayores rezagos esa relación se vuelve más difusa. 2.1.3 Promedios móviles 2.1.3.1 Promedio Móvil Simple (SMA) El promedio móvil simple es una técnica estadística utilizada para suavizar series de tiempo mediante la creación de un promedio de los valores en un intervalo específico de tiempo. Permite facilitar la identificación de tendencias subyacentes al hacer que las variaciones estacionales y aleatorias sean menos evidentes. Una de sus ventajas es que proporciona una visión clara de la tendencia general de los datos a lo largo del tiempo. SMA se usa principalmente en análisis financiero, como en el seguimiento de precios de acciones, proyecciones de ventas, y otras métricas de negocio. 2.1.3.2 Promedio Móvil Exponencial (EMA). Es similar al promedio móvil simple (SMA), pero con un enfoque que da más peso a los datos más recientes. Este puede ser más representativo de la tendencia actual en series de tiempo con alta volatilidad. Se aplica en diversas áreas de análisis de datos, como en el monitoreo de ventas, pronósticos de demanda, y otros indicadores de rendimiento. En las gráficas se puede observar como los promedios eliminan el ruido de los picos ocasionados los días de fin de semana, donde se realizan menos pagos de remesas sabados, domingos y festivos y mayores pagos en los días viernes. 2.2 Serie de tiempo por Fecha de Origen Se agrupa el monto en dólares por la variable objetivo. Datos_FO &lt;- aggregate(Monto_USD ~ Fecha_Origen, data = Datos, sum) 2.2.1 Uso de la librería XTS Por ser una base irregular con periodicidad diaria, se decidió usar la libreria XTS por la utilización de las fechas exactas. # Crear la serie de tiempo serie_xts1 &lt;- xts(Datos_FO$Monto_USD, order.by = Datos_FO$Fecha_Origen) head(serie_xts1) ## [,1] ## 2018-11-20 658.18 ## 2019-02-04 253.15 ## 2019-05-22 405.03 ## 2019-08-10 250.02 ## 2019-12-13 598.19 ## 2020-02-24 20.70 Se pueden obvervar casos atipicos desde 20 de noviembre de 2018, que corresponden a remesas que fueron reclamadas muy posteriormente a la originación, ya que las fechas de pago estan desde el 01 de octubre de 2023, y que debieron surtir un proceso especial. Se procede a realizar la limpieza de datos atipicos, dejando unicamente las remesas que hayan sido originadas hasta 30 dias antes del pago: 2.2.2 Gráfico de rezago para la serie de tiempo Según las gráficas parece al igual que en el analisis con fecha de pago, que existe algo de autocorrelación en los primeros rezagos, pero para mayores rezagos esa relación se vuelve más difusa. 2.2.3 Promedios móviles 2.2.3.1 Promedio Móvil Simple (SMA) 2.2.3.2 Promedio Móvil Exponencial (EMA). En las gráficas se puede observar como los promedios eliminan el ruido de los picos ocasionados los días de fin de semana, donde se realizan menos pagos de remesas sabados, domingos y festivos y mayores pagos en los días viernes. "],["preprocesamiento-y-visualizacion.html", "3 PREPROCESAMIENTO Y VISUALIZACION 3.1 Descomposición, estacionariedad y diferenciación - Serie de tiempo por Fecha de Pago 3.2 Verificar si la serie es esacionaria 3.3 Funciones acf y pacf 3.4 Modelo ARIMA 3.5 Diagnóstico del modelo. 3.6 Prediccones del Modelo ARIMA 3.7 Punto de cambio de la serie de tiempo 3.8 Gráfica ACF y PACF de los residuos 3.9 Prueba de Ljung-Box 3.10 Normalidad de los residuos 3.11 Gráfico Q-Q (Quantile-Quantile)", " 3 PREPROCESAMIENTO Y VISUALIZACION 3.1 Descomposición, estacionariedad y diferenciación - Serie de tiempo por Fecha de Pago #install.packages(&quot;zoo&quot;) library(TTR) library(zoo) # Convertir el objeto &#39;Datos_FP&#39; en un ts con frecuencia semanal (si aplica) fechas &lt;- seq(as.Date(&quot;2023-01-01&quot;), as.Date(&quot;2024-10-10&quot;), by = &quot;day&quot;) serie_ts &lt;- zoo(Datos_FP$Monto_USD, order.by = fechas) #serie_ts_fo &lt;- zoo(Datos_FO$Monto_USD, order.by = fechas) 3.2 Verificar si la serie es esacionaria # Verificar si la serie es estacionaria # Instala y carga la librería si aún no la tienes #install.packages(&quot;tseries&quot;) library(tseries) # Aplica la prueba ADF a tu serie de tiempo adf_test &lt;- adf.test(serie_ts) print(adf_test) ## ## Augmented Dickey-Fuller Test ## ## data: serie_ts ## Dickey-Fuller = -7.4089, Lag order = 8, p-value = 0.01 ## alternative hypothesis: stationary El resultado de la prueba Dickey-Fuller Aumentada (ADF) indica que la serie es estacionaria por lo cual no requiere de ninguna transformacion. Estadístico de Dickey-Fuller = -7.4089: Este es el valor calculado para el estadístico de prueba. Un valor más negativo tiende a indicar estacionariedad, ya que refuerza el rechazo de la hipótesis nula de no estacionariedad. p-value = 0.01: Este p-valor es bajo (generalmente menor a 0.05 es un umbral común para significancia). Dado que el p-valor es 0.01, puedes rechazar la hipótesis nula de no estacionariedad con un 99% de confianza. Esto significa que hay una fuerte evidencia de que tu serie es estacionaria. alternative hypothesis: stationary: La hipótesis alternativa de la prueba es que la serie es estacionaria. Dado que el p-valor es bajo, este resultado respalda la hipótesis alternativa, indicando estacionariedad. En resumen, se puede concluir concluir que la serie es estacionaria con un nivel de confianza alto. Esto significa que sus propiedades estadísticas, como la media y la varianza, se mantienen constantes a lo largo del tiempo, lo cual es un buen punto de partida para aplicar modelos de series de tiempo como ARIMA, que asumen estacionariedad. 3.3 Funciones acf y pacf # Cargar librerías necesarias library(ggplot2) library(gridExtra) # Crear gráficos ACF y PACF par(mfrow = c(2, 1)) # Configura el área de gráficos # Gráfico ACF acf(serie_ts, main = &quot;Función de Autocorrelacion (ACF)&quot;, lag.max = 7) # Gráfico PACF pacf(serie_ts, main = &quot;Función de Autocorrelacion Parcial (PACF)&quot;, lag.max = 7) # Restaurar configuración de gráficos par(mfrow = c(1, 1)) library(forecast) #install.packages(&quot;TTR&quot;) # Asegurarnos de que la frecuencia corresponde al periodo deseado #serie_ts &lt;- ts(Datos_FP$Monto_USD, frequency = 365, start = c(2023, 1)) # Calcula la tendencia usando una media móvil, ajusta el número de periodos según sea necesario tendencia &lt;- SMA(Datos_FP$Monto_USD, n = 30) # Media móvil de 30 días # Calcula la estacionalidad (residuo de los datos menos la tendencia) estacionalidad &lt;- Datos_FP$Monto_USD - tendencia # Promedia por semana para capturar un patrón estacional semanal estacionalidad_media &lt;- tapply(estacionalidad, as.POSIXlt(fechas)$yday %% 7, mean, na.rm = TRUE) estacionalidad &lt;- rep(estacionalidad_media, length.out = length(Datos_FP$Monto_USD)) # Calcula el residuo (parte aleatoria) residuo &lt;- Datos_FP$Monto_USD - tendencia - estacionalidad #library(ggplot2) df_componentes &lt;- data.frame( Fecha = fechas, Datos = Datos_FP$Monto_USD, Tendencia = tendencia, Estacionalidad = estacionalidad, Residuo = residuo ) # Graficar cada componente usando ggplot2 ggplot(df_componentes, aes(x = Fecha)) + geom_line(aes(y = Datos)) + labs(title = &quot;Data&quot;, y = &quot;data&quot;) ggplot(df_componentes, aes(x = Fecha)) + geom_line(aes(y = Estacionalidad)) + labs(title = &quot;Estacionalidad&quot;, y = &quot;seasonal&quot;) ggplot(df_componentes, aes(x = Fecha)) + geom_line(aes(y = Tendencia)) + labs(title = &quot;Tendencia&quot;, y = &quot;trend&quot;) ggplot(df_componentes, aes(x = Fecha)) + geom_line(aes(y = Residuo)) + labs(title = &quot;Residuo&quot;, y = &quot;remainder&quot;) 3.4 Modelo ARIMA modelo_arima &lt;- auto.arima(serie_ts) summary(modelo_arima) ## Series: serie_ts ## ARIMA(1,1,2) ## ## Coefficients: ## ar1 ma1 ma2 ## -0.6595 -0.1343 -0.8306 ## s.e. 0.0698 0.0500 0.0485 ## ## sigma^2 = 5.659e+12: log likelihood = -10433.64 ## AIC=20875.29 AICc=20875.35 BIC=20893.18 ## ## Training set error measures: ## ME RMSE MAE MPE MAPE MASE ACF1 ## Training set 225291 2371592 1881706 -26.87723 51.80463 0.8184988 -0.0180491 El resultado del summary(modelo_arima) obtenido brinda información detallada sobre el modelo ARIMA que se ha ajustado a la serie de tiempo. 3.4.1 Modelo ARIMA ARIMA(1,1,2): Esto indica que el modelo es un ARIMA con los siguientes parámetros: 1: Este número representa el orden autorregresivo \\(p\\) (número de términos pasados de la serie que se incluyen). 1: Este número representa el orden de diferenciación \\(d\\) (número de veces que los datos se diferencian para lograr estacionariedad). 2: Este número representa el orden de media móvil \\(q\\) (número de términos pasados de los errores que se incluyen). 3.4.2 Coeficientes del Modelo Los coeficientes estimados del modelo son: ar1: Este coeficiente está relacionado con el término autorregresivo del modelo. Un valor de \\(-0.6595\\) sugiere que existe una relación negativa entre el valor actual y el valor pasado en la serie de tiempo. En otras palabras, si el valor en el período anterior es alto, el valor en el período actual tiende a ser bajo, y viceversa. ma1 y ma2: Estos coeficientes están relacionados con los términos de media móvil. ma1 = -0.1343: Indica que el primer término de error tiene una relación negativa con el valor actual. ma2 = -0.8306: Este coeficiente tiene una relación negativa más fuerte, lo que sugiere que los errores de dos períodos atrás tienen un impacto considerable en el valor actual. 3.4.3 Errores Estándar (s.e.) Los errores estándar asociados a cada coeficiente te dan una idea de la incertidumbre de estas estimaciones: - s.e. ar1 = 0.0698 - s.e. ma1 = 0.0500 - s.e. ma2 = 0.0485 Un error estándar pequeño en relación con el coeficiente indica que la estimación del coeficiente es relativamente precisa. 3.4.4 Sigma^2 sigma^2 = 5.659e+12: Este valor representa la varianza de los residuos del modelo. Un valor más bajo indicaría un mejor ajuste del modelo, ya que implica que los errores (diferencias entre los valores reales y los valores ajustados) son pequeños. 3.4.5 Log Likelihood, AIC, AICc, BIC Log Likelihood = -10433.64: Este valor es utilizado para comparar modelos; más cerca de cero es mejor. AIC = 20875.29: El Criterio de Información de Akaike (AIC) se utiliza para comparar diferentes modelos. Un valor menor indica un mejor modelo, considerando la complejidad del modelo. AICc = 20875.35: Es una versión corregida del AIC que se aplica a muestras pequeñas. Se prefiere usarlo cuando la muestra es relativamente pequeña en comparación con la complejidad del modelo. BIC = 20893.18: El Criterio de Información de Bayesian (BIC) también se utiliza para la comparación de modelos, penalizando más fuertemente los modelos complejos que el AIC. Al igual que el AIC, un valor menor es mejor. 3.4.6 Resumen El modelo ARIMA(1,1,2) sugiere que hay una relación significativa entre los valores pasados y los errores en la serie de tiempo. Además, los valores de AIC y BIC permitirán comparar este modelo con otros modelos que se podrían considerar para ver si hay mejores alternativas. 3.5 Diagnóstico del modelo. checkresiduals(modelo_arima) ## ## Ljung-Box test ## ## data: Residuals from ARIMA(1,1,2) ## Q* = 329.69, df = 7, p-value &lt; 2.2e-16 ## ## Model df: 3. Total lags used: 10 3.6 Prediccones del Modelo ARIMA predicciones &lt;- forecast(modelo_arima, h = 12) #&#39;h&#39; indica cuántos períodos quieras predecir plot(predicciones) 3.7 Punto de cambio de la serie de tiempo # Instalar el paquete changepoint si no lo tienes #install.packages(&quot;changepoint&quot;) # Cargar el paquete library(changepoint) # Supongamos que tienes tu serie de tiempo &#39;serie_ts&#39; # Aplicar cpt.mean para detectar cambios en la media punto_cambio &lt;- cpt.mean(serie_ts) # Mostrar los resultados summary(punto_cambio) ## Created Using changepoint version 2.2.4 ## Changepoint type : Change in mean ## Method of analysis : AMOC ## Test Statistic : Normal ## Type of penalty : MBIC with value, 19.4263 ## Minimum Segment Length : 1 ## Maximum no. of cpts : 1 ## Changepoint Locations : 456 segun los resultados obtenidos, se detectó un punto de cambio en la serie de tiempo. Changepoint type: Define el tipo de cambio detectado. En este caso, es un cambio en la media de la serie (Change in mean), lo que implica que la función cpt.mean buscó variaciones significativas en el nivel promedio de los datos. Method of analysis: AMOC: El método AMOC (At Most One Change) implica que el análisis se ha limitado a identificar solo un posible cambio en la serie de tiempo. Test Statistic: Normal: La estadística de prueba utilizada para detectar el cambio es el test de normalidad, adecuado para datos que siguen una distribución normal. Type of penalty: MBIC with value, 19.4263: La penalización aplicada es la MBIC (Modified Bayesian Information Criterion), que ayuda a determinar la ubicación del cambio sin sobreajustar el modelo. El valor específico de esta penalización fue 19.4263, lo cual afecta el número de cambios detectados al favorecer soluciones con menos cambios. Minimum Segment Length: 1: Indica que la longitud mínima de un segmento entre los puntos de cambio es 1. Es decir, el análisis considera que el cambio puede ocurrir incluso en segmentos de un solo punto. Maximum no. of cpts: 1: Se limitó el número máximo de puntos de cambio a 1, lo cual es consistente con el método AMOC usado en el análisis. Changepoint Locations: 456: El único punto de cambio detectado se encuentra en la posición 456 de la serie de tiempo. Esto significa que se encontró un cambio significativo en la media en esa posición específica de la serie. # Graficar la serie de tiempo con los puntos de cambio plot(punto_cambio, main = &quot;Puntos de Cambio en la Media&quot;) 3.8 Gráfica ACF y PACF de los residuos acf(residuals(modelo_arima)) pacf(residuals(modelo_arima)) 3.9 Prueba de Ljung-Box Box.test(residuals(modelo_arima), lag = 10, type = &quot;Ljung-Box&quot;) ## ## Box-Ljung test ## ## data: residuals(modelo_arima) ## X-squared = 329.69, df = 10, p-value &lt; 2.2e-16 La prueba de Ljung-Box evalúa si los residuos del modelo ARIMA están autocorrelacionados. Esto es importante porque, idealmente, los residuos deberían comportarse como ruido blanco (es decir, sin patrones de autocorrelación) para indicar que el modelo ha capturado adecuadamente la estructura de la serie de tiempo. En esta prueba: Hipótesis nula (H0): No hay autocorrelación en los residuos, es decir, los residuos son ruido blanco. Hipótesis alternativa (H1): Existe autocorrelación en los residuos. 3.9.1 Interpretación de los Resultados Valor de X-squared: El estadístico de prueba X-squared es 329.69. Este valor indica cuánta autocorrelación existe entre los residuos en función del número de retardos especificado (en este caso, 10 retardos). Grados de libertad (df): En este caso, son 10, lo cual corresponde al número de retardos que seleccionaste para el test. p-value: El valor p es menor que \\(2.2 \\times 10^{-16}\\), lo cual es extremadamente bajo. 3.9.2 Conclusión Dado que el valor p es mucho menor que el nivel de significancia típico (0.05), rechazamos la hipótesis nula. Esto sugiere que existe autocorrelación significativa en los residuos del modelo ARIMA. Esto indica que el modelo no ha capturado completamente los patrones en la serie de tiempo, por lo que podría necesitar ajustes adicionales en los valores de p, d, y q o en su parametrización general. Para mejorar el modelo, considera: 1. Reexaminar el orden del modelo (ajustar p, d, q). 2. Probar otros modelos ARIMA, como un SARIMA si hay componentes estacionales. 3. Verificar si la serie requiere transformaciones adicionales. 3.10 Normalidad de los residuos shapiro.test(residuals(modelo_arima)) ## ## Shapiro-Wilk normality test ## ## data: residuals(modelo_arima) ## W = 0.95135, p-value = 8.511e-14 hist(residuals(modelo_arima), main = &quot;Histograma de Residuos&quot;, xlab = &quot;Residuos&quot;) 3.11 Gráfico Q-Q (Quantile-Quantile) qqnorm(residuals(modelo_arima)) qqline(residuals(modelo_arima), col = &quot;red&quot;) Dado el valor p tan bajo (inferior a un nivel de significancia típico de 0.05), rechazamos la hipótesis nula. Esto significa que los residuos del modelo no se distribuyen normalmente. "]]
